var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// src/server.ts
import debug2 from "debug";
import EventEmitter32 from "eventemitter3";
import { JSONRPCServer } from "json-rpc-2.0";
import { v4 as uuidv42 } from "uuid";

// src/client.ts
import debug from "debug";
import EventEmitter3 from "eventemitter3";
import { JSONRPCClient } from "json-rpc-2.0";
import { v4 as uuidv4 } from "uuid";

// src/popup.ts
import { LitElement, html, css } from "lit";
var ModalPopup = class extends LitElement {
  constructor() {
    super(...arguments);
    this.isOpen = false;
    this.iframeSrc = "";
    this.handleIframeLoad = () => {
      const { contentWindow } = this.iframeElement || {};
      this.resolve?.(contentWindow);
    };
    this.handleIframeError = (e) => {
      this.reject?.(e.error);
      this.closeModal();
    };
  }
  render() {
    return html`
      <div class="modal ${this.isOpen ? "show" : ""}">
        <div class="modal-content">
          <span class="close-button" @click="${this.closeModal}">&times;</span>
          <iframe src="about:blank"></iframe>
        </div>
      </div>
    `;
  }
  async openModal(url) {
    const defer = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
    this.iframeSrc = url;
    this.isOpen = true;
    if (this.iframeElement) {
      this.iframeElement.src = url;
    }
    return defer;
  }
  firstUpdated() {
    this.iframeElement = this.renderRoot.querySelector("iframe");
    if (this.iframeElement) {
      this.iframeElement.addEventListener("load", this.handleIframeLoad);
      this.iframeElement.addEventListener("error", this.handleIframeError);
      if (this.iframeSrc) {
        this.iframeElement.src = this.iframeSrc;
      }
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.iframeElement) {
      this.iframeElement.removeEventListener("load", this.handleIframeLoad);
      this.iframeElement.removeEventListener("error", this.handleIframeError);
      this.iframeElement = null;
    }
  }
  closeModal() {
    this.isOpen = false;
    this.iframeSrc = "";
  }
};
ModalPopup.styles = css`
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      justify-content: center;
      align-items: center;
    }
    .modal.show {
      display: flex;
    }
    .modal-content {
      background-color: #fff;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      /* Default size for larger screens */
      width: 480px;
      height: 640px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    /* Fullscreen iframe for mobile devices */
    @media (max-width: 768px) {
      .modal-content {
        width: 100%;
        height: 100%;
        border-radius: 0; /* Remove rounded corners on mobile */
      }
    }
    .close-button {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 24px;
      cursor: pointer;
      z-index: 10;
    }
    iframe {
      width: 100%;
      height: 100%;
      border: none;
    }
  `;
ModalPopup.properties = {
  isOpen: { type: Boolean },
  iframeSrc: { type: String }
};

// src/client.ts
var clientLog = debug("upProvider:client");

// src/index.ts
var arrayChanged = (_addresses1, _addresses2) => {
  const addresses1 = _addresses1 ?? [];
  const addresses2 = _addresses2 ?? [];
  for (let i = 0; i < addresses1.length || i < addresses2.length; i++) {
    const is1Null = addresses1[i] === null || addresses1[i] === void 0;
    const is2Null = addresses2[i] === null || addresses2[i] === void 0;
    if (is1Null && is2Null) {
      continue;
    }
    if (addresses1[i] !== addresses2[i]) {
      return true;
    }
  }
  return false;
};
var cleanupAccounts = (values) => {
  const output = [];
  for (const value of values) {
    if (!value || /^0x0+$/.test(value)) {
      break;
    }
    output.push(value);
  }
  return output;
};

// src/server.ts
var serverLog = debug2("upProvider:server");
var _accounts, _contextAccounts, _chainId, _rpcUrls, _buffered, _serverChannel, _server, _getter, _setter;
var _UPClientChannel = class extends EventEmitter32 {
  constructor(serverChannel, window2, element, id, server, getter, setter) {
    super();
    this.window = window2;
    this.element = element;
    this.id = id;
    __privateAdd(this, _accounts, []);
    __privateAdd(this, _contextAccounts, []);
    __privateAdd(this, _chainId, 0);
    __privateAdd(this, _rpcUrls, []);
    __privateAdd(this, _buffered, []);
    __privateAdd(this, _serverChannel);
    __privateAdd(this, _server);
    __privateAdd(this, _getter);
    __privateAdd(this, _setter);
    __privateSet(this, _getter, getter);
    __privateSet(this, _setter, setter);
    __privateSet(this, _serverChannel, serverChannel);
    __privateSet(this, _server, server);
  }
  emit(event, ...args) {
    if (__privateGet(this, _buffered)) {
      __privateGet(this, _buffered).push([event, args]);
      return false;
    }
    return super.emit(event, ...args);
  }
  resume(delay = 0) {
    const buffered = __privateGet(this, _buffered);
    if (!buffered) {
      return;
    }
    __privateSet(this, _buffered, void 0);
    setTimeout(() => {
      while (buffered.length > 0) {
        const val = buffered.shift();
        if (val) {
          const [event, args] = val;
          super.emit(event, ...args);
        }
      }
    }, delay);
  }
  on(event, fn, context) {
    this.resume(100);
    return super.on(event, fn, context);
  }
  addListener(event, fn, context) {
    this.resume(100);
    return super.addListener(event, fn, context);
  }
  async send(method, params) {
    __privateGet(this, _serverChannel).postMessage({
      jsonrpc: "2.0",
      id: uuidv42(),
      method,
      params
    });
  }
  async setAllowedAccounts(accounts) {
    serverLog("allowedAccounts", accounts);
    const accountsChanged = arrayChanged(__privateGet(this, _accounts), accounts);
    if (accountsChanged) {
      const wasEmpty = __privateGet(this, _accounts).length === 0;
      __privateSet(this, _accounts, [...accounts]);
      if (__privateGet(this, _getter).call(this)) {
        await this.send("accountsChanged", cleanupAccounts([...__privateGet(this, _accounts)]));
        if (wasEmpty !== (__privateGet(this, _accounts).length === 0)) {
          this.emit(__privateGet(this, _getter).call(this) && __privateGet(this, _accounts).length > 0 ? "connected" : "disconnected");
        }
      }
    }
  }
  set allowedAccounts(accounts) {
    this.setAllowedAccounts(accounts);
  }
  get allowedAccounts() {
    return [...__privateGet(this, _accounts)];
  }
  async setContextAccounts(contextAccounts) {
    const accountsChanged = arrayChanged(__privateGet(this, _contextAccounts), contextAccounts);
    if (accountsChanged) {
      serverLog("contextAccounts", contextAccounts);
      __privateSet(this, _contextAccounts, [...contextAccounts]);
      await this.send("contextAccountsChanged", cleanupAccounts([...__privateGet(this, _contextAccounts)]));
    }
  }
  get contextAccounts() {
    return [...__privateGet(this, _contextAccounts)];
  }
  async setupChannel(enable, accounts, contextAccounts, chainId) {
    const accountsChanged = arrayChanged(__privateGet(this, _accounts), accounts);
    let sendAccountsChanged = false;
    if (accountsChanged) {
      serverLog("allowedAccounts", accounts);
      __privateSet(this, _accounts, [...accounts]);
      sendAccountsChanged = enable;
    }
    const contextAccountsChanged = arrayChanged(__privateGet(this, _contextAccounts), contextAccounts);
    let sendContextAccountsChanged = false;
    if (contextAccountsChanged) {
      serverLog("contextAccounts", contextAccounts);
      __privateSet(this, _contextAccounts, [...contextAccounts]);
      sendContextAccountsChanged = true;
    }
    let sendChainChanged = false;
    if (__privateGet(this, _chainId) !== chainId) {
      serverLog("chainId", contextAccounts);
      __privateSet(this, _chainId, chainId);
      sendChainChanged = true;
    }
    if (enable !== this.enable) {
      serverLog("enable", enable);
      __privateGet(this, _setter).call(this, enable);
      sendAccountsChanged = true;
    }
    if (sendChainChanged) {
      await this.send("chainChanged", [chainId]);
      this.emit("chainChanged", chainId);
    }
    if (sendContextAccountsChanged) {
      await this.send("contextAccountsChanged", cleanupAccounts([...__privateGet(this, _contextAccounts)]));
    }
    if (sendAccountsChanged) {
      await this.send("accountsChanged", cleanupAccounts(__privateGet(this, _getter).call(this) ? [...__privateGet(this, _accounts)] : []));
      this.emit(__privateGet(this, _getter).call(this) && __privateGet(this, _accounts).length > 0 ? "connected" : "disconnected");
    }
  }
  async setEnable(value) {
    if (value !== this.enable) {
      __privateGet(this, _setter).call(this, value);
      this.send("accountsChanged", cleanupAccounts(__privateGet(this, _getter).call(this) ? [...__privateGet(this, _accounts)] : []));
      this.emit(__privateGet(this, _getter).call(this) && __privateGet(this, _accounts).length > 0 ? "connected" : "disconnected");
    }
  }
  set enable(value) {
    this.setEnable(value);
  }
  get enable() {
    return __privateGet(this, _getter).call(this);
  }
  async setChainId(chainId) {
    if (__privateGet(this, _chainId) !== chainId) {
      __privateSet(this, _chainId, chainId);
      await this.send("chainChanged", [chainId]);
      this.emit("chainChanged", chainId);
    }
  }
  get chainId() {
    return __privateGet(this, _chainId);
  }
  set chainId(chainId) {
    this.setChainId(chainId);
  }
  async setRpcUrls(rpcUrls) {
    if (arrayChanged(rpcUrls, __privateGet(this, _rpcUrls))) {
      __privateSet(this, _rpcUrls, rpcUrls);
      await this.send("rpcUrlsChanged", rpcUrls);
    }
  }
  get rpcUrls() {
    return [...__privateGet(this, _rpcUrls)];
  }
  set rpcUrls(rpcUrls) {
    this.setRpcUrls(rpcUrls);
  }
  close() {
    const el = this.element || this.window;
    if (el.upChannel === this) {
      el.upChannel = void 0;
    }
    __privateGet(this, _serverChannel).close();
  }
};
_accounts = new WeakMap();
_contextAccounts = new WeakMap();
_chainId = new WeakMap();
_rpcUrls = new WeakMap();
_buffered = new WeakMap();
_serverChannel = new WeakMap();
_server = new WeakMap();
_getter = new WeakMap();
_setter = new WeakMap();
var _options, _channels;
var _UPProviderConnector = class extends EventEmitter32 {
  constructor(channels, options) {
    super();
    __privateAdd(this, _options);
    __privateAdd(this, _channels);
    this._getChannels = () => {
      return __privateGet(this, _channels);
    };
    this._getOptions = () => {
      return __privateGet(this, _options);
    };
    __privateSet(this, _channels, channels);
    __privateSet(this, _options, options);
  }
  close() {
    if (this._getOptions().providerHandler) {
      window.removeEventListener("message", this._getOptions().providerHandler);
      this._getOptions().providerHandler = void 0;
    }
  }
  get provider() {
    return this._getOptions().provider;
  }
  async setAllowedAccounts(accounts) {
    const allowedAccountsChanged = arrayChanged(this._getOptions().allowedAccounts, accounts);
    if (allowedAccountsChanged) {
      this._getOptions().allowedAccounts = [...accounts];
      for (const item of this.channels.values()) {
        await item.setAllowedAccounts(cleanupAccounts(this._getOptions().allowedAccounts));
      }
    }
  }
  get allowedAccounts() {
    return cleanupAccounts(this._getOptions().allowedAccounts);
  }
  set allowedAccounts(accounts) {
    this.setAllowedAccounts(accounts);
  }
  async setChainId(chainId) {
    if (this._getOptions().chainId !== chainId) {
      this._getOptions().chainId = chainId;
      for (const item of this.channels.values()) {
        await item.setChainId(this._getOptions().chainId);
      }
    }
  }
  get chainId() {
    return this._getOptions().chainId;
  }
  set chainId(chainId) {
    this.setChainId(chainId);
  }
  /**
   * Get a map of all clients by their ID.
   */
  get channels() {
    return new Map(this._getChannels());
  }
  /**
   * Find the client for the element, window or proxy object of the client.
   * @param id
   * @returns actual UPClientChannel
   */
  getChannel(id) {
    let _id = id;
    if (typeof _id === "string") {
      return this._getChannels().get(_id) || null;
    }
    if ("element" in _id || "window" in _id) {
      _id = _id.element || _id.window;
    }
    for (const item of this._getChannels().values()) {
      if (item.window === _id || item.element === _id) {
        return item;
      }
    }
    return null;
  }
  /**
   * Inject additional addresses into the client's accountsChanged event.
   * Account[0] will be linked to the signed when making transactions.
   * Starting at Account[1] is where additional addresses are injected.
   * This routine injects on all connections. You can also inject using
   * the channel's allowedAccounts method.
   * @param page list of addresses
   */
  async setContextAccounts(contextAccounts) {
    const contextAccountsChanged = arrayChanged(this._getOptions().contextAccounts, contextAccounts);
    if (contextAccountsChanged) {
      this._getOptions().contextAccounts = [...contextAccounts];
      for (const item of this.channels.values()) {
        await item.setContextAccounts(cleanupAccounts(this._getOptions().contextAccounts));
      }
    }
  }
  get contextAccounts() {
    return cleanupAccounts(this._getOptions().contextAccounts);
  }
  set contextAccounts(contextAccounts) {
    this.setContextAccounts(contextAccounts);
  }
  /**
   * Connect this provider externally. This will be called during initial construction
   * but can be called at a later time if desired to re-initialize or tear down
   * the connection.
   * @param provider
   * @param rpcUrls
   */
  async setupProvider(provider, rpcUrls) {
    this._getOptions().promise = new Promise((resolve, reject) => {
      ;
      (async () => {
        try {
          const oldCallback = this._getOptions().providerAccountsChangedCallback;
          if (this._getOptions().provider && oldCallback) {
            this._getOptions().provider?.off("accountsChanged", oldCallback);
            this._getOptions().providerAccountsChangedCallback = void 0;
          }
          this._getOptions().provider = provider;
          const newRpcUrls = Array.isArray(rpcUrls) ? rpcUrls : [rpcUrls];
          if (arrayChanged(newRpcUrls, this._getOptions().rpcUrls)) {
            this._getOptions().rpcUrls = newRpcUrls;
            for (const item of this.channels.values()) {
              await item.setRpcUrls(this._getOptions().rpcUrls);
            }
          }
          const _chainId2 = await this._getOptions().provider?.request({
            method: "eth_chainId",
            params: []
          }) || this._getOptions().chainId;
          for (const item of this.channels.values()) {
            await item.setChainId(this._getOptions().chainId);
          }
          const _accounts2 = await this._getOptions().provider?.request({
            method: "eth_accounts",
            params: []
          }) || [];
          const accountsChanged = arrayChanged(this._getOptions().allowedAccounts, _accounts2);
          if (accountsChanged) {
            this._getOptions().chainId = _chainId2;
            this._getOptions().allowedAccounts = [..._accounts2];
            for (const item of this.channels.values()) {
              await item.setAllowedAccounts(cleanupAccounts(this._getOptions().allowedAccounts));
            }
          }
          const accountsChangedCallback = async (_accounts3) => {
            const accountsChanged2 = arrayChanged(this._getOptions().allowedAccounts, _accounts3);
            if (accountsChanged2) {
              this._getOptions().allowedAccounts = [..._accounts3];
              for (const item of this.channels.values()) {
                await item.setAllowedAccounts(cleanupAccounts(this._getOptions().allowedAccounts));
              }
            }
          };
          if (this._getOptions().provider) {
            this._getOptions().providerAccountsChangedCallback = accountsChangedCallback;
            this._getOptions().provider.on("accountsChanged", accountsChangedCallback);
          }
          resolve();
        } catch (err) {
          reject(err);
        }
      })();
    });
  }
};
_options = new WeakMap();
_channels = new WeakMap();
var globalUPProvider = null;
function getUPProviderChannel(id) {
  if (id == null) {
    return null;
  }
  if (!globalUPProvider) {
    throw new Error("Global UP Provider not set up");
  }
  return globalUPProvider.getChannel(id);
}
function createUPProviderConnector(provider, rpcUrls) {
  if (globalUPProvider) {
    return globalUPProvider;
  }
  const channels = /* @__PURE__ */ new Map();
  const options = {
    provider: provider ?? null,
    rpcUrls: Array.isArray(rpcUrls) ? rpcUrls : rpcUrls != null ? [rpcUrls] : [],
    chainId: 0,
    allowedAccounts: [],
    contextAccounts: [],
    promise: Promise.resolve()
  };
  globalUPProvider = new _UPProviderConnector(channels, options);
  serverLog("server listen", window);
  options.providerHandler = (event) => {
    if (event.data === "upProvider:hasProvider") {
      let iframe = null;
      for (const element of document.querySelectorAll("iframe")) {
        if (element.contentWindow === event.source) {
          serverLog("server hasProvider", element);
          iframe = element;
          break;
        }
      }
      const previous = iframe ? getUPProviderChannel(iframe) : getUPProviderChannel(event.source);
      let channelId;
      const serverChannel = event.ports[0];
      const server = new JSONRPCServer();
      let enabled = false;
      if (previous) {
        channelId = previous.id;
      } else {
        channelId = uuidv42();
      }
      const channel_ = new _UPClientChannel(
        serverChannel,
        event.source,
        iframe,
        channelId,
        server,
        () => enabled,
        (value) => {
          enabled = value;
        }
      );
      server.applyMiddleware(async (next, request) => {
        await options.promise;
        const { method: _method, params: _params, id, jsonrpc } = request;
        const method = typeof _method === "string" ? _method : _method.method;
        const params = typeof _method === "string" ? _params : _method.params;
        switch (method) {
          case "chainChanged":
            serverLog("short circuit response", request, [options.chainId]);
            channel_.emit("chainChanged", options.chainId);
            return {
              ...request,
              result: [options.chainId]
            };
          case "accounts": {
            const accounts = cleanupAccounts(enabled ? [...channel_.allowedAccounts] : []);
            serverLog("short circuit response", request);
            channel_.emit("requestAccounts", accounts);
            return {
              ...request,
              result: accounts
            };
          }
          case "contextAccountsChanged": {
            const accounts = cleanupAccounts([...channel_.contextAccounts]);
            serverLog("short circuit response", request);
            channel_.emit("contextAccountsChanged", accounts);
            return {
              ...request,
              result: accounts
            };
          }
          case "eth_requestAccounts": {
            const accounts = cleanupAccounts(enabled ? [...channel_.allowedAccounts] : []);
            serverLog("short circuit response", request, accounts);
            channel_.emit("requestAccounts", accounts);
            return {
              ...request,
              result: accounts
            };
          }
          case "eth_chainId":
            return {
              ...request,
              result: options.chainId
            };
          case "eth_accounts": {
            const accounts = cleanupAccounts(enabled ? [...channel_.allowedAccounts] : []);
            channel_.emit("accountsChanged", accounts);
            return {
              ...request,
              result: accounts
            };
          }
        }
        try {
          if (!options.provider) {
            throw new Error("Global Provider not connected");
          }
          const response = await options.provider.request({ method, params });
          serverLog("response", request, response);
          return {
            id,
            jsonrpc,
            result: response
          };
        } catch (error) {
          if (!/method (.*?) not supported./.test(error.message || "")) {
            console.error(error);
            const response = {
              id,
              jsonrpc,
              error
            };
            serverLog("response error", request, response);
            return response;
          }
        }
        serverLog("request", request);
        return await next(request);
      });
      const channelHandler = (event2) => {
        if (event2.data.type === "upProvider:windowInitialized") {
          serverLog("channel created", event2.data.type, event2.data);
          globalUPProvider?.emit("channelCreated", channel_.element || channel_.window || null, channel_);
          const destination = channel_.element || channel_.window || null;
          if (destination != null) {
            ;
            destination.upChannel = channel_;
            const event3 = new CustomEvent("up-channel-connected", {
              detail: {
                channel: channel_,
                chainId: options.chainId,
                allowedAccounts: options.allowedAccounts,
                contextAccounts: options.contextAccounts,
                rpcUrls: options.rpcUrls,
                enable: channel_.enable
              }
            });
            destination.dispatchEvent(event3);
          }
          return;
        }
        try {
          const request = {
            ...event2.data,
            id: `${channelId}:${event2.data.id}`
          };
          server.receive(request).then(
            (response) => {
              serverLog("server response", response);
              if (response && typeof response.id === "string") {
                if (request.method === "eth_sendTransaction") {
                  if (response.error) {
                    console.error("Error sending transaction", response.error);
                  }
                  channel_.emit("sentTransaction", {
                    from: request.params[0]?.from,
                    to: request.params[0]?.to,
                    value: request.params[0]?.value,
                    result: response.result,
                    error: response.error
                  });
                }
                if (!response.id.startsWith(`${channelId}:`)) {
                  console.error(`Invalid response id ${response.id} on channel ${channelId}`);
                  return;
                }
                serverChannel?.postMessage({
                  ...response,
                  id: JSON.parse(response.id.replace(`${channelId}:`, ""))
                });
              }
            },
            (error) => {
              if (request.method === "eth_sendTransaction") {
                if (error) {
                  console.error("Error sending transaction", error);
                }
                channel_.emit("sentTransaction", {
                  from: request.params[0]?.from,
                  to: request.params[0]?.to,
                  value: request.params[0]?.value,
                  error
                });
              }
              serverChannel?.postMessage({
                error,
                id: JSON.parse(request.id.replace(`${channelId}:`, ""))
              });
            }
          );
        } catch (error) {
          console.error("Error parsing JSON RPC request", error, event2);
        }
      };
      channels.set(channelId, channel_);
      serverLog("server hasProvider", event.data, event.ports);
      serverChannel.addEventListener("message", channelHandler);
      serverChannel.start();
      serverLog("server accept", serverChannel);
      serverChannel?.postMessage({
        type: "upProvider:windowInitialize",
        chainId: options.chainId,
        allowedAccounts: options.allowedAccounts,
        contextAccounts: options.contextAccounts,
        rpcUrls: options.rpcUrls
      });
      channel_.emit("connected");
    }
  };
  window.addEventListener("message", options.providerHandler);
  return globalUPProvider;
}
export {
  createUPProviderConnector,
  getUPProviderChannel
};
//# sourceMappingURL=server.mjs.map