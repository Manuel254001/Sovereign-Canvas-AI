{"version":3,"sources":["../src/server.ts","../src/client.ts","../src/popup.ts","../src/index.ts"],"sourcesContent":["import debug from 'debug'\nimport EventEmitter3, { type EventEmitter } from 'eventemitter3'\nimport { type JSONRPCError, type JSONRPCErrorResponse, type JSONRPCParams, JSONRPCServer, type JSONRPCSuccessResponse } from 'json-rpc-2.0'\nimport { v4 as uuidv4 } from 'uuid'\nimport { arrayChanged, cleanupAccounts } from '.'\n\nconst serverLog = debug('upProvider:server')\ninterface UPClientChannelEvents {\n  connected: () => void\n  disconnected: () => void\n  contextAccountsChanged: (accounts: `0x${string}`[]) => void\n  accountsChanged: (accounts: `0x${string}`[]) => void\n  requestAccounts: (accounts: `0x${string}`[]) => void\n  chainChanged: (chainId: number) => void\n  injected: (accounts: `0x${string}`[]) => void\n  sentTransaction: (tx: { from: `0x${string}`; to: `0x${string}`; value?: bigint; error?: JSONRPCError; result?: any }) => void\n}\n\n/**\n * API for client channel, each time an iframe's UPClientProvider is allocated and connected\n * the UPProviderConnector will create and emit a new UPClientChannel.\n * The UPClientChannel will have the API to control that channel.\n * The configuration will default to values from the UPProviderConnector but enable will be false.\n */\ninterface UPClientChannel {\n  readonly window: Window\n  readonly element: HTMLIFrameElement | null\n  readonly id: string\n\n  /**\n   * Return an array listing the events for which the emitter has registered\n   * listeners.\n   */\n  eventNames(): Array<EventEmitter.EventNames<UPClientChannelEvents>>\n\n  /**\n   * Return the listeners registered for a given event.\n   */\n  listeners<T extends EventEmitter.EventNames<UPClientChannelEvents>>(event: T): Array<EventEmitter.EventListener<UPClientChannelEvents, T>>\n\n  /**\n   * Return the number of listeners listening to a given event.\n   */\n  listenerCount(event: EventEmitter.EventNames<UPClientChannelEvents>): number\n\n  /**\n   * Calls each of the listeners registered for a given event.\n   */\n  emit<T extends EventEmitter.EventNames<UPClientChannelEvents>>(event: T, ...args: EventEmitter.EventArgs<UPClientChannelEvents, T>): boolean\n\n  /**\n   * Add a listener for a given event.\n   */\n  on<T extends EventEmitter.EventNames<UPClientChannelEvents>>(event: T, fn: EventEmitter.EventListener<UPClientChannelEvents, T>, context?: any): this\n  addListener<T extends EventEmitter.EventNames<UPClientChannelEvents>>(event: T, fn: EventEmitter.EventListener<UPClientChannelEvents, T>, context?: any): this\n\n  /**\n   * Add a one-time listener for a given event.\n   */\n  once<T extends EventEmitter.EventNames<UPClientChannelEvents>>(event: T, fn: EventEmitter.EventListener<UPClientChannelEvents, T>, context?: any): this\n\n  /**\n   * Remove the listeners of a given event.\n   */\n  removeListener<T extends EventEmitter.EventNames<UPClientChannelEvents>>(event: T, fn?: EventEmitter.EventListener<UPClientChannelEvents, T>, context?: any, once?: boolean): this\n  off<T extends EventEmitter.EventNames<UPClientChannelEvents>>(event: T, fn?: EventEmitter.EventListener<UPClientChannelEvents, T>, context?: any, once?: boolean): this\n\n  /**\n   * Remove all listeners, or those of the specified event.\n   */\n  removeAllListeners(event?: EventEmitter.EventNames<UPClientChannelEvents>): this\n\n  /**\n   * Resume after a delay\n   * @param delay - delay in milliseconds\n   */\n  resume(delay: number): void\n  /**\n   * Send message to dapp.\n   * @param method - method name/event\n   * @param params - parameters\n   */\n  send(method: string, params: unknown[]): Promise<void>\n\n  /**\n   * This represents the normal \"eth_accounts\" method list.\n   * @param accounts - list of addresses\n   */\n  setAllowedAccounts(accounts: `0x${string}`[]): Promise<void>\n\n  /**\n   * This represents the normal \"eth_accounts\" method list. (setter mirrors setAllowedAccounts)\n   */\n  set allowedAccounts(accounts: `0x${string}`[])\n\n  /**\n   * This represents the normal \"eth_accounts\" method list.\n   * @returns list of accounts\n   */\n  get allowedAccounts(): `0x${string}`[]\n\n  /**\n   * These are extra accounts sent to each provider. In the ue.io grid, this is used to\n   * represent the account that is the grid owner.\n   * @param accounts - list of addresses\n   */\n  setContextAccounts(contextAccounts: `0x${string}`[]): Promise<void>\n\n  /**\n   * These are extra accounts sent to each provider. In the ue.io grid, this is used to\n   * represent the account that is the grid owner. (setter mirrors setContextAccounts)\n   * @param accounts - list of addresses\n   */\n  set contextAccounts(contextAccounts: `0x${string}`[])\n\n  /**\n   * These are extra accounts sent to each provider. In the ue.io grid, this is used to\n   * represent the account that is the grid owner.\n   * @returns list of addresses\n   */\n  get contextAccounts(): `0x${string}`[]\n\n  /**\n   * ChainId\n   * @param chainId - chain id\n   */\n  setChainId(chainId: number): Promise<void>\n\n  /**\n   * ChainId\n   * @param chainId - chain id\n   */\n  set chainId(chainId: number)\n\n  /**\n   * ChainId\n   * @returns chain id\n   */\n  get chainId(): number\n\n  /**\n   * Enable or disable the channel.\n   * @param enable - enable or disable the channel\n   */\n  setEnable(enable: boolean): Promise<void>\n\n  /**\n   * Enable or disable the channel.\n   * @returns is channel enabled\n   */\n  get enable(): boolean\n\n  /**\n   * Enable or disable the channel.\n   * @param enable - enable or disable the channel\n   */\n  set enable(value: boolean)\n\n  /**\n   * RPC urls\n   * @param rpcUrls - list of rpc urls (used by client provider to short circuit requests)\n   */\n  setRpcUrls(rpcUrls: string[]): Promise<void>\n\n  /**\n   * RPC urls\n   * @param rpcUrls - list of rpc urls (used by client provider to short circuit requests)\n   */\n  set rpcUrls(rpcUrls: string[])\n\n  /**\n   * RPC urls\n   * @returns list of rpc urls (used by client provider to short circuit requests)\n   */\n  get rpcUrls(): string[]\n\n  /**\n   * Helper to setup the channel with all the necessary information.\n   * @param enable - enable\n   * @param accounts - accounts (allowed accounts)\n   * @param contextAccounts - context accounts\n   * @param chainId - chainId\n   */\n  setupChannel(enable: boolean, accounts: `0x${string}`[], contextAccounts: `0x${string}`[], chainId: number): Promise<void>\n\n  /**\n   * Close the channel\n   */\n  close(): void\n}\n\nclass _UPClientChannel extends EventEmitter3<UPClientChannelEvents> implements UPClientChannel {\n  #accounts: `0x${string}`[] = []\n  #contextAccounts: `0x${string}`[] = []\n  #chainId = 0\n  #rpcUrls: string[] = []\n  #buffered?: Array<[keyof UPClientChannelEvents, unknown[]]> = []\n  #serverChannel: MessagePort\n  #server: JSONRPCServer\n  readonly #getter: () => boolean\n  readonly #setter: (value: boolean) => void\n\n  constructor(serverChannel: MessagePort, public readonly window: Window, public readonly element: HTMLIFrameElement | null, public readonly id: string, server: JSONRPCServer, getter: () => boolean, setter: (value: boolean) => void) {\n    super()\n    this.#getter = getter\n    this.#setter = setter\n    this.#serverChannel = serverChannel\n    this.#server = server\n  }\n\n  emit<T extends EventEmitter.EventNames<UPClientChannelEvents>>(event: T, ...args: EventEmitter.EventArgs<UPClientChannelEvents, T>): boolean {\n    if (this.#buffered) {\n      this.#buffered.push([event, args])\n      return false\n    }\n    return super.emit(event, ...args)\n  }\n\n  resume(delay = 0) {\n    const buffered = this.#buffered\n    if (!buffered) {\n      return\n    }\n    this.#buffered = undefined\n    setTimeout(() => {\n      while (buffered.length > 0) {\n        const val = buffered.shift()\n        if (val) {\n          const [event, args] = val\n          super.emit(event, ...(args as any))\n        }\n      }\n    }, delay)\n  }\n\n  on<T extends EventEmitter.EventNames<UPClientChannelEvents>>(event: T, fn: EventEmitter.EventListener<UPClientChannelEvents, T>, context?: any) {\n    this.resume(100)\n    return super.on(event, fn, context)\n  }\n  addListener<T extends EventEmitter.EventNames<UPClientChannelEvents>>(event: T, fn: EventEmitter.EventListener<UPClientChannelEvents, T>, context?: any) {\n    this.resume(100)\n    return super.addListener(event, fn, context)\n  }\n\n  public async send(method: string, params: unknown[]): Promise<void> {\n    this.#serverChannel.postMessage({\n      jsonrpc: '2.0',\n      id: uuidv4(),\n      method,\n      params,\n    })\n  }\n\n  public async setAllowedAccounts(accounts: `0x${string}`[]): Promise<void> {\n    serverLog('allowedAccounts', accounts)\n    const accountsChanged = arrayChanged(this.#accounts, accounts)\n    if (accountsChanged) {\n      const wasEmpty = this.#accounts.length === 0\n      this.#accounts = [...accounts]\n      if (this.#getter()) {\n        await this.send('accountsChanged', cleanupAccounts([...this.#accounts]))\n        if (wasEmpty !== (this.#accounts.length === 0)) {\n          this.emit(this.#getter() && this.#accounts.length > 0 ? 'connected' : 'disconnected')\n        }\n      }\n    }\n  }\n  public set allowedAccounts(accounts: `0x${string}`[]) {\n    this.setAllowedAccounts(accounts)\n  }\n  public get allowedAccounts(): `0x${string}`[] {\n    return [...this.#accounts]\n  }\n\n  public async setContextAccounts(contextAccounts: `0x${string}`[]): Promise<void> {\n    const accountsChanged = arrayChanged(this.#contextAccounts, contextAccounts)\n    if (accountsChanged) {\n      serverLog('contextAccounts', contextAccounts)\n      this.#contextAccounts = [...contextAccounts]\n      await this.send('contextAccountsChanged', cleanupAccounts([...this.#contextAccounts]))\n    }\n  }\n  public get contextAccounts(): `0x${string}`[] {\n    return [...this.#contextAccounts]\n  }\n\n  public async setupChannel(enable: boolean, accounts: `0x${string}`[], contextAccounts: `0x${string}`[], chainId: number): Promise<void> {\n    const accountsChanged = arrayChanged(this.#accounts, accounts)\n    let sendAccountsChanged = false\n    if (accountsChanged) {\n      serverLog('allowedAccounts', accounts)\n      this.#accounts = [...accounts]\n      sendAccountsChanged = enable\n    }\n    const contextAccountsChanged = arrayChanged(this.#contextAccounts, contextAccounts)\n    let sendContextAccountsChanged = false\n    if (contextAccountsChanged) {\n      serverLog('contextAccounts', contextAccounts)\n      this.#contextAccounts = [...contextAccounts]\n      sendContextAccountsChanged = true\n    }\n    let sendChainChanged = false\n    if (this.#chainId !== chainId) {\n      serverLog('chainId', contextAccounts)\n      this.#chainId = chainId\n      sendChainChanged = true\n    }\n    if (enable !== this.enable) {\n      serverLog('enable', enable)\n      this.#setter(enable)\n      sendAccountsChanged = true\n    }\n    if (sendChainChanged) {\n      await this.send('chainChanged', [chainId])\n      this.emit('chainChanged', chainId)\n    }\n    if (sendContextAccountsChanged) {\n      await this.send('contextAccountsChanged', cleanupAccounts([...this.#contextAccounts]))\n    }\n    if (sendAccountsChanged) {\n      await this.send('accountsChanged', cleanupAccounts(this.#getter() ? [...this.#accounts] : []))\n      this.emit(this.#getter() && this.#accounts.length > 0 ? 'connected' : 'disconnected')\n    }\n  }\n\n  public async setEnable(value: boolean): Promise<void> {\n    if (value !== this.enable) {\n      this.#setter(value)\n      this.send('accountsChanged', cleanupAccounts(this.#getter() ? [...this.#accounts] : []))\n      this.emit(this.#getter() && this.#accounts.length > 0 ? 'connected' : 'disconnected')\n    }\n  }\n  public set enable(value: boolean) {\n    this.setEnable(value)\n  }\n  public get enable(): boolean {\n    return this.#getter()\n  }\n\n  public async setChainId(chainId: number): Promise<void> {\n    if (this.#chainId !== chainId) {\n      this.#chainId = chainId\n      await this.send('chainChanged', [chainId])\n      this.emit('chainChanged', chainId)\n    }\n  }\n  public get chainId(): number {\n    return this.#chainId\n  }\n  public set chainId(chainId: number) {\n    this.setChainId(chainId)\n  }\n\n  public async setRpcUrls(rpcUrls: string[]): Promise<void> {\n    if (arrayChanged(rpcUrls, this.#rpcUrls)) {\n      this.#rpcUrls = rpcUrls\n      await this.send('rpcUrlsChanged', rpcUrls)\n    }\n  }\n  public get rpcUrls(): string[] {\n    return [...this.#rpcUrls]\n  }\n  public set rpcUrls(rpcUrls: string[]) {\n    this.setRpcUrls(rpcUrls)\n  }\n\n  public close() {\n    const el: any = this.element || this.window\n    if (el.upChannel === this) {\n      el.upChannel = undefined\n    }\n    this.#serverChannel.close()\n  }\n}\n\ninterface UPProviderEndpointEvents {\n  accountsChanged: (accounts: `0x${string}`[]) => void\n  chainChanged: (chainId: number) => void\n  connect: ({ chainId }: { chainId: number }) => void\n  disconnect: (error: Error) => void\n}\ninterface UPProviderEndpoint {\n  on<T extends EventEmitter.EventNames<UPProviderEndpointEvents>>(event: T, fn: EventEmitter.EventListener<UPProviderEndpointEvents, T>, context?: any): this\n  off<T extends EventEmitter.EventNames<UPProviderEndpointEvents>>(event: T, fn: EventEmitter.EventListener<UPProviderEndpointEvents, T>, context?: any): this\n  request(message: { method: string; params: JSONRPCParams }, clientParams?: any): Promise<any>\n  request(method: string | { method: string; params: JSONRPCParams }, params?: JSONRPCParams, clientParams?: any): Promise<any>\n}\n\ntype UPProviderConnectorOptions = {\n  providerHandler?: (e: MessageEvent) => void\n  allowedAccounts: `0x${string}`[]\n  contextAccounts: `0x${string}`[]\n  provider: UPProviderEndpoint\n  providerAccountsChangedCallback?: (accounts: `0x${string}`[]) => void\n  promise: Promise<void>\n  rpcUrls: string[]\n  chainId: number\n}\n\ninterface UPProviderConnectorEvents {\n  channelCreated: (id: HTMLIFrameElement | Window | string, channel: UPClientChannel) => void\n}\n\n/**\n * API for provider connector\n */\ninterface UPProviderConnector {\n  /**\n   * Return an array listing the events for which the emitter has registered\n   * listeners.\n   */\n  eventNames(): Array<EventEmitter.EventNames<UPProviderConnectorEvents>>\n\n  /**\n   * Return the listeners registered for a given event.\n   */\n  listeners<T extends EventEmitter.EventNames<UPProviderConnectorEvents>>(event: T): Array<EventEmitter.EventListener<UPProviderConnectorEvents, T>>\n\n  /**\n   * Return the number of listeners listening to a given event.\n   */\n  listenerCount(event: EventEmitter.EventNames<UPProviderConnectorEvents>): number\n\n  /**\n   * Calls each of the listeners registered for a given event.\n   */\n  emit<T extends EventEmitter.EventNames<UPProviderConnectorEvents>>(event: T, ...args: EventEmitter.EventArgs<UPProviderConnectorEvents, T>): boolean\n\n  /**\n   * Add a listener for a given event.\n   */\n  on<T extends EventEmitter.EventNames<UPProviderConnectorEvents>>(event: T, fn: EventEmitter.EventListener<UPProviderConnectorEvents, T>, context?: any): this\n  addListener<T extends EventEmitter.EventNames<UPProviderConnectorEvents>>(event: T, fn: EventEmitter.EventListener<UPProviderConnectorEvents, T>, context?: any): this\n\n  /**\n   * Add a one-time listener for a given event.\n   */\n  once<T extends EventEmitter.EventNames<UPProviderConnectorEvents>>(event: T, fn: EventEmitter.EventListener<UPProviderConnectorEvents, T>, context?: any): this\n\n  /**\n   * Remove the listeners of a given event.\n   */\n  removeListener<T extends EventEmitter.EventNames<UPProviderConnectorEvents>>(event: T, fn?: EventEmitter.EventListener<UPProviderConnectorEvents, T>, context?: any, once?: boolean): this\n  off<T extends EventEmitter.EventNames<UPProviderConnectorEvents>>(event: T, fn?: EventEmitter.EventListener<UPProviderConnectorEvents, T>, context?: any, once?: boolean): this\n\n  /**\n   * Remove all listeners, or those of the specified event.\n   */\n  removeAllListeners(event?: EventEmitter.EventNames<UPProviderConnectorEvents>): this\n\n  close(): void\n\n  get provider(): UPProviderEndpoint\n\n  /**\n   * Get a map of all clients by their ID.\n   */\n  get channels(): Map<string, UPClientChannel>\n\n  /**\n   * Find the client for the element, window or proxy object of the client.\n   * @param id\n   * @returns actual UPClientChannel\n   */\n  getChannel(id: string | Window | HTMLIFrameElement | UPClientChannel | null): UPClientChannel | null\n\n  /**\n   * Inject additional addresses into the client's accountsChanged event.\n   * Account[0] will be linked to the signed when making transactions.\n   * Starting at Account[1] is where additional addresses are injected.\n   * This routine injects on all connections. You can also inject using\n   * the channel's allowedAccounts method.\n   * @param page list of addresses\n   */\n  setContextAccounts(accounts: `0x${string}`[]): Promise<void>\n  set contextAccounts(accounts: `0x${string}`[])\n  get contextAccounts(): `0x${string}`[]\n\n  setAllowedAccounts(accounts: `0x${string}`[]): Promise<void>\n  set allowedAccounts(accounts: `0x${string}`[])\n  get allowedAccounts(): `0x${string}`[]\n\n  setChainId(chainId: number): Promise<void>\n  set chainId(chainId: number)\n  get chainId(): number\n\n  /**\n   * Connect this provider externally. This will be called during initial construction\n   * but can be called at a later time if desired to re-initialize or tear down\n   * the connection.\n   * @param provider\n   * @param rpcUrls\n   */\n  setupProvider(provider: UPProviderEndpoint, rpcUrls: string | string[]): Promise<void>\n}\n\nclass _UPProviderConnector extends EventEmitter3<UPProviderConnectorEvents> implements UPProviderConnector {\n  #options: UPProviderConnectorOptions\n  #channels: Map<string, UPClientChannel>\n\n  constructor(channels: Map<string, UPClientChannel>, options: any) {\n    super()\n    this.#channels = channels\n\n    // This is a private late initialization of the class properties.\n    // Since there is no way to do a await inside of a constructor this is used to provide\n    // certain values late, but still have them hidden from external access.\n    this.#options = options as UPProviderConnectorOptions\n  }\n\n  private _getChannels = (): Map<string, UPClientChannel> => {\n    return this.#channels\n  }\n  private _getOptions = (): UPProviderConnectorOptions => {\n    return this.#options\n  }\n\n  close() {\n    if (this._getOptions().providerHandler) {\n      window.removeEventListener('message', this._getOptions().providerHandler as any)\n      this._getOptions().providerHandler = undefined\n    }\n  }\n\n  get provider(): UPProviderEndpoint {\n    return this._getOptions().provider\n  }\n\n  async setAllowedAccounts(accounts: `0x${string}`[]): Promise<void> {\n    const allowedAccountsChanged = arrayChanged(this._getOptions().allowedAccounts, accounts)\n    if (allowedAccountsChanged) {\n      this._getOptions().allowedAccounts = [...accounts]\n      for (const item of this.channels.values()) {\n        await item.setAllowedAccounts(cleanupAccounts(this._getOptions().allowedAccounts))\n      }\n    }\n  }\n  get allowedAccounts(): `0x${string}`[] {\n    return cleanupAccounts(this._getOptions().allowedAccounts)\n  }\n  set allowedAccounts(accounts: `0x${string}`[]) {\n    this.setAllowedAccounts(accounts)\n  }\n\n  async setChainId(chainId: number): Promise<void> {\n    if (this._getOptions().chainId !== chainId) {\n      this._getOptions().chainId = chainId\n      for (const item of this.channels.values()) {\n        await item.setChainId(this._getOptions().chainId)\n      }\n    }\n  }\n  get chainId(): number {\n    return this._getOptions().chainId\n  }\n  set chainId(chainId: number) {\n    this.setChainId(chainId)\n  }\n  /**\n   * Get a map of all clients by their ID.\n   */\n  get channels(): Map<string, UPClientChannel> {\n    return new Map(this._getChannels())\n  }\n\n  /**\n   * Find the client for the element, window or proxy object of the client.\n   * @param id\n   * @returns actual UPClientChannel\n   */\n  getChannel(id: string | Window | HTMLIFrameElement | UPClientChannel | null): UPClientChannel | null {\n    let _id = id\n    if (typeof _id === 'string') {\n      return this._getChannels().get(_id) || null\n    }\n    if ('element' in (_id as any) || 'window' in (_id as any)) {\n      _id = (_id as UPClientChannel).element || (_id as UPClientChannel).window\n    }\n    for (const item of this._getChannels().values()) {\n      if (item.window === _id || item.element === _id) {\n        return item\n      }\n    }\n    return null\n  }\n\n  /**\n   * Inject additional addresses into the client's accountsChanged event.\n   * Account[0] will be linked to the signed when making transactions.\n   * Starting at Account[1] is where additional addresses are injected.\n   * This routine injects on all connections. You can also inject using\n   * the channel's allowedAccounts method.\n   * @param page list of addresses\n   */\n  async setContextAccounts(contextAccounts: `0x${string}`[]) {\n    const contextAccountsChanged = arrayChanged(this._getOptions().contextAccounts, contextAccounts)\n    if (contextAccountsChanged) {\n      this._getOptions().contextAccounts = [...contextAccounts]\n      for (const item of this.channels.values()) {\n        await item.setContextAccounts(cleanupAccounts(this._getOptions().contextAccounts))\n      }\n    }\n  }\n  get contextAccounts(): `0x${string}`[] {\n    return cleanupAccounts(this._getOptions().contextAccounts)\n  }\n  set contextAccounts(contextAccounts: `0x${string}`[]) {\n    this.setContextAccounts(contextAccounts)\n  }\n\n  /**\n   * Connect this provider externally. This will be called during initial construction\n   * but can be called at a later time if desired to re-initialize or tear down\n   * the connection.\n   * @param provider\n   * @param rpcUrls\n   */\n  async setupProvider(provider: any, rpcUrls: string | string[]): Promise<void> {\n    this._getOptions().promise = new Promise<void>((resolve, reject) => {\n      ;(async () => {\n        try {\n          const oldCallback = this._getOptions().providerAccountsChangedCallback\n          if (this._getOptions().provider && oldCallback) {\n            this._getOptions().provider?.off('accountsChanged', oldCallback)\n            this._getOptions().providerAccountsChangedCallback = undefined\n          }\n          this._getOptions().provider = provider\n          const newRpcUrls = Array.isArray(rpcUrls) ? rpcUrls : [rpcUrls]\n          if (arrayChanged(newRpcUrls, this._getOptions().rpcUrls)) {\n            this._getOptions().rpcUrls = newRpcUrls\n            for (const item of this.channels.values()) {\n              await item.setRpcUrls(this._getOptions().rpcUrls)\n            }\n          }\n          const _chainId =\n            (await this._getOptions().provider?.request({\n              method: 'eth_chainId',\n              params: [],\n            })) || this._getOptions().chainId\n          for (const item of this.channels.values()) {\n            await item.setChainId(this._getOptions().chainId)\n          }\n          const _accounts =\n            (await this._getOptions().provider?.request({\n              method: 'eth_accounts',\n              params: [],\n            })) || []\n          const accountsChanged = arrayChanged(this._getOptions().allowedAccounts, _accounts)\n          if (accountsChanged) {\n            this._getOptions().chainId = _chainId\n            this._getOptions().allowedAccounts = [..._accounts]\n            for (const item of this.channels.values()) {\n              await item.setAllowedAccounts(cleanupAccounts(this._getOptions().allowedAccounts))\n            }\n          }\n          const accountsChangedCallback = async (_accounts: `0x${string}`[]) => {\n            const accountsChanged = arrayChanged(this._getOptions().allowedAccounts, _accounts)\n            if (accountsChanged) {\n              this._getOptions().allowedAccounts = [..._accounts]\n              for (const item of this.channels.values()) {\n                await item.setAllowedAccounts(cleanupAccounts(this._getOptions().allowedAccounts))\n              }\n            }\n          }\n          if (this._getOptions().provider) {\n            this._getOptions().providerAccountsChangedCallback = accountsChangedCallback\n            this._getOptions().provider.on('accountsChanged', accountsChangedCallback)\n          }\n          resolve()\n        } catch (err) {\n          reject(err)\n        }\n      })()\n    })\n  }\n}\n\nlet globalUPProvider: UPProviderConnector | null = null\n\n/**\n * Global method to find channel in case `up-channel-connected` event was missed.\n *\n * @param id how to find the UPClientChannel instance (this can be the id, frame (not the frame's element id) or window)\n * @returns UPClientChannel\n */\nfunction getUPProviderChannel(id: string | Window | HTMLIFrameElement | UPClientChannel | null): UPClientChannel | null {\n  if (id == null) {\n    return null\n  }\n  if (!globalUPProvider) {\n    throw new Error('Global UP Provider not set up')\n  }\n  return globalUPProvider.getChannel(id)\n}\n\n/**\n * Install a global UPProvider inside of the particular window which will listen for client\n * connections and establish them. It will fire `up-channel-connected` on the particular iframe if it's reachable.\n * It will fire a local `channelCreated` event as well.\n *\n * @param provider the initial provider to proxy\n * @param rpcUrls rpc urls to give to the clients to locally connect for non eth_sendTransaction and so on.\n * @returns The global provider and event sing for `channelCreated` events.\n */\nfunction createUPProviderConnector(provider?: any, rpcUrls?: string | string[]): UPProviderConnector {\n  if (globalUPProvider) {\n    return globalUPProvider\n  }\n  const channels = new Map<string, UPClientChannel>()\n\n  // Allow for late initialization of class properties.\n  const options: UPProviderConnectorOptions = {\n    provider: provider ?? null,\n    rpcUrls: Array.isArray(rpcUrls) ? rpcUrls : rpcUrls != null ? [rpcUrls] : [],\n    chainId: 0,\n    allowedAccounts: [],\n    contextAccounts: [],\n    promise: Promise.resolve(),\n  }\n  globalUPProvider = new _UPProviderConnector(channels, options)\n\n  serverLog('server listen', window)\n\n  // Server handler to accept new client provider connections\n  options.providerHandler = (event: MessageEvent) => {\n    if (event.data === 'upProvider:hasProvider') {\n      let iframe: HTMLIFrameElement | null = null\n      for (const element of document.querySelectorAll('iframe')) {\n        if (element.contentWindow === event.source) {\n          serverLog('server hasProvider', element)\n          iframe = element\n          break\n        }\n      }\n      const previous = iframe ? getUPProviderChannel(iframe) : getUPProviderChannel(event.source as Window)\n      let channelId: string\n      const serverChannel = event.ports[0]\n      const server = new JSONRPCServer()\n      let enabled = false\n\n      // Server handler to forward requests to the provider\n      if (previous) {\n        channelId = previous.id\n      } else {\n        channelId = uuidv4()\n      }\n\n      // Wrapper for representation of client connection inside of global provider space.\n      const channel_ = new _UPClientChannel(\n        serverChannel,\n        event.source as Window,\n        iframe,\n        channelId,\n        server,\n        () => enabled,\n        value => {\n          enabled = value\n        }\n      )\n\n      server.applyMiddleware(async (next, request) => {\n        await options.promise\n        const { method: _method, params: _params, id, jsonrpc } = request\n        const method =\n          typeof _method === 'string'\n            ? _method\n            : (\n                _method as unknown as {\n                  method: string\n                  params: unknown[]\n                }\n              ).method\n        const params =\n          typeof _method === 'string'\n            ? _params\n            : (\n                _method as unknown as {\n                  method: string\n                  params: unknown[]\n                }\n              ).params\n        switch (method) {\n          case 'chainChanged':\n            serverLog('short circuit response', request, [options.chainId])\n            channel_.emit('chainChanged', options.chainId)\n            return {\n              ...request,\n              result: [options.chainId],\n            } as JSONRPCSuccessResponse\n          case 'accounts': {\n            const accounts = cleanupAccounts(enabled ? [...channel_.allowedAccounts] : [])\n            serverLog('short circuit response', request)\n            channel_.emit('requestAccounts', accounts)\n            return {\n              ...request,\n              result: accounts,\n            } as JSONRPCSuccessResponse\n          }\n          case 'contextAccountsChanged': {\n            const accounts = cleanupAccounts([...channel_.contextAccounts])\n            serverLog('short circuit response', request)\n            channel_.emit('contextAccountsChanged', accounts)\n            return {\n              ...request,\n              result: accounts,\n            } as JSONRPCSuccessResponse\n          }\n          case 'eth_requestAccounts': {\n            const accounts = cleanupAccounts(enabled ? [...channel_.allowedAccounts] : [])\n            serverLog('short circuit response', request, accounts)\n            channel_.emit('requestAccounts', accounts)\n            return {\n              ...request,\n              result: accounts,\n            } as JSONRPCSuccessResponse\n          }\n          case 'eth_chainId':\n            return {\n              ...request,\n              result: options.chainId,\n            } as JSONRPCSuccessResponse\n          case 'eth_accounts': {\n            const accounts = cleanupAccounts(enabled ? [...channel_.allowedAccounts] : [])\n            channel_.emit('accountsChanged', accounts)\n            return {\n              ...request,\n              result: accounts,\n            } as JSONRPCSuccessResponse\n          }\n        }\n        try {\n          if (!options.provider) {\n            throw new Error('Global Provider not connected')\n          }\n          const response = await options.provider.request({ method, params })\n          serverLog('response', request, response)\n          return {\n            id,\n            jsonrpc,\n            result: response,\n          } as JSONRPCSuccessResponse\n        } catch (error) {\n          if (!/method (.*?) not supported./.test((error as { message: string }).message || '')) {\n            console.error(error)\n            const response = {\n              id,\n              jsonrpc,\n              error,\n            } as JSONRPCErrorResponse\n            serverLog('response error', request, response)\n            return response\n          }\n        }\n        serverLog('request', request)\n        return await next(request)\n      })\n\n      const channelHandler = (event: MessageEvent) => {\n        if (event.data.type === 'upProvider:windowInitialized') {\n          serverLog('channel created', event.data.type, event.data)\n          globalUPProvider?.emit('channelCreated', channel_.element || channel_.window || null, channel_)\n          const destination = channel_.element || channel_.window || null\n          if (destination != null) {\n            ;(destination as any).upChannel = channel_\n            const event = new CustomEvent('up-channel-connected', {\n              detail: {\n                channel: channel_,\n                chainId: options.chainId,\n                allowedAccounts: options.allowedAccounts,\n                contextAccounts: options.contextAccounts,\n                rpcUrls: options.rpcUrls,\n                enable: channel_.enable,\n              },\n            })\n            destination.dispatchEvent(event)\n          }\n          return\n        }\n        try {\n          const request = {\n            ...event.data,\n            id: `${channelId}:${event.data.id}`,\n          }\n          server.receive(request).then(\n            response => {\n              serverLog('server response', response)\n              if (response && typeof response.id === 'string') {\n                if (request.method === 'eth_sendTransaction') {\n                  if (response.error) {\n                    console.error('Error sending transaction', response.error)\n                  }\n                  channel_.emit('sentTransaction', {\n                    from: request.params[0]?.from,\n                    to: request.params[0]?.to,\n                    value: request.params[0]?.value,\n                    result: response.result,\n                    error: response.error,\n                  })\n                }\n                if (!response.id.startsWith(`${channelId}:`)) {\n                  console.error(`Invalid response id ${response.id} on channel ${channelId}`)\n                  return\n                }\n                serverChannel?.postMessage({\n                  ...response,\n                  id: JSON.parse(response.id.replace(`${channelId}:`, '')),\n                })\n              }\n            },\n            (error: any) => {\n              if (request.method === 'eth_sendTransaction') {\n                if (error) {\n                  console.error('Error sending transaction', error)\n                }\n                channel_.emit('sentTransaction', {\n                  from: request.params[0]?.from,\n                  to: request.params[0]?.to,\n                  value: request.params[0]?.value,\n                  error,\n                })\n              }\n              serverChannel?.postMessage({\n                error,\n                id: JSON.parse(request.id.replace(`${channelId}:`, '')),\n              })\n            }\n          )\n        } catch (error) {\n          console.error('Error parsing JSON RPC request', error, event)\n        }\n      }\n\n      channels.set(channelId, channel_)\n      serverLog('server hasProvider', event.data, event.ports)\n      serverChannel.addEventListener('message', channelHandler)\n      serverChannel.start()\n\n      serverLog('server accept', serverChannel)\n      serverChannel?.postMessage({\n        type: 'upProvider:windowInitialize',\n        chainId: options.chainId,\n        allowedAccounts: options.allowedAccounts,\n        contextAccounts: options.contextAccounts,\n        rpcUrls: options.rpcUrls,\n      })\n      channel_.emit('connected')\n    }\n  }\n  window.addEventListener('message', options.providerHandler)\n  return globalUPProvider\n}\n\nexport { type UPClientChannel, type UPClientChannelEvents, type UPProviderConnector, type UPProviderConnectorEvents, type UPProviderEndpoint, type UPProviderEndpointEvents, getUPProviderChannel, createUPProviderConnector }\n","import debug from 'debug'\nimport EventEmitter3, { type EventEmitter } from 'eventemitter3'\nimport { JSONRPCClient, type JSONRPCParams } from 'json-rpc-2.0'\nimport { v4 as uuidv4 } from 'uuid'\nimport image from './UniversalProfiles_Apps_Logo_96px.svg'\nimport { create } from 'domain'\nimport { createWalletPopup } from './popup'\nimport { cleanupAccounts } from './index'\n\nconst clientLog = debug('upProvider:client')\n\ntype RequestQueueItem = {\n  resolve: () => unknown\n  reject: (reason: unknown) => unknown\n  sent: boolean\n  id: number | string\n  method: string\n  params: unknown[]\n}\n\ntype UPWindowConfig =\n  | Window\n  | null\n  | undefined\n  | {\n      url: string\n      mode: 'popup' | 'iframe'\n    }\n\ninterface UPClientProviderEvents {\n  connected: () => void\n  disconnected: () => void\n  accountsChanged: (accounts: `0x${string}`[]) => void\n  contextAccountsChanged: (contextAccounts: `0x${string}`[]) => void\n  requestAccounts: (accounts: `0x${string}`[]) => void\n  chainChanged: (chainId: number) => void\n  injected: (page: `0x${string}`) => void\n  rpcUrls: (rpcUrls: string[]) => void\n  windowClosed: () => void\n  initialized: () => void\n}\n\n/**\n * Internal closure for UPClientProvider to allow late initialization of class.\n */\ntype UPClientProviderOptions = {\n  client?: JSONRPCClient\n  chainId: () => number\n  allowedAccounts: () => `0x${string}`[]\n  contextAccounts: () => `0x${string}`[]\n  window?: Window\n  clientChannel?: MessagePort\n  startupPromise: Promise<void>\n  restart: () => void\n  init?: {\n    chainId: number\n    allowedAccounts: `0x${string}`[]\n    contextAccounts: `0x${string}`[]\n    rpcUrls: string[]\n  }\n}\n\nconst pendingRequests = new Map<string, RequestQueueItem>()\n\n/**\n * Public interface for UPClientProvider.\n */\ninterface UPClientProvider {\n  get isUPClientProvider(): boolean\n  /**\n   * Return an array listing the events for which the emitter has registered\n   * listeners.\n   */\n  eventNames(): Array<EventEmitter.EventNames<UPClientProviderEvents>>\n\n  /**\n   * Return the listeners registered for a given event.\n   */\n  listeners<T extends EventEmitter.EventNames<UPClientProviderEvents>>(event: T): Array<EventEmitter.EventListener<UPClientProviderEvents, T>>\n\n  /**\n   * Return the number of listeners listening to a given event.\n   */\n  listenerCount(event: EventEmitter.EventNames<UPClientProviderEvents>): number\n\n  /**\n   * Calls each of the listeners registered for a given event.\n   */\n  emit<T extends EventEmitter.EventNames<UPClientProviderEvents>>(event: T, ...args: EventEmitter.EventArgs<UPClientProviderEvents, T>): boolean\n\n  /**\n   * Add a listener for a given event.\n   */\n  on<T extends EventEmitter.EventNames<UPClientProviderEvents>>(event: T, fn: EventEmitter.EventListener<UPClientProviderEvents, T>, context?: any): this\n  addListener<T extends EventEmitter.EventNames<UPClientProviderEvents>>(event: T, fn: EventEmitter.EventListener<UPClientProviderEvents, T>, context?: any): this\n\n  /**\n   * Add a one-time listener for a given event.\n   */\n  once<T extends EventEmitter.EventNames<UPClientProviderEvents>>(event: T, fn: EventEmitter.EventListener<UPClientProviderEvents, T>, context?: any): this\n\n  /**\n   * Remove the listeners of a given event.\n   */\n  removeListener<T extends EventEmitter.EventNames<UPClientProviderEvents>>(event: T, fn?: EventEmitter.EventListener<UPClientProviderEvents, T>, context?: any, once?: boolean): this\n  off<T extends EventEmitter.EventNames<UPClientProviderEvents>>(event: T, fn?: EventEmitter.EventListener<UPClientProviderEvents, T>, context?: any, once?: boolean): this\n\n  /**\n   * Remove all listeners, or those of the specified event.\n   */\n  removeAllListeners(event?: EventEmitter.EventNames<UPClientProviderEvents>): this\n\n  request(method: string, params?: JSONRPCParams, clientParams?: any): Promise<any>\n  request(method: { method: string; params?: JSONRPCParams }, clientParams?: any): Promise<any>\n\n  /**\n   * Get the current chainId this is configured for and connected to.\n   */\n  get chainId(): number\n\n  /**\n   * Mirrors allowedAccounts, the accounts the provider is connected to\n   */\n  get accounts(): `0x${string}`[]\n\n  /**\n   * Additional context accounts provided by the parent connector.\n   * Inside of the universaleverything grid this will contain the account\n   * of the owner of the displayed grid (i.e. the owner of the profile being displayed.)\n   */\n  get contextAccounts(): `0x${string}`[]\n\n  get isConnected(): boolean\n\n  get isMiniApp(): Promise<boolean>\n}\n\n/**\n * Internal class for UPClientProvider.\n */\nclass _UPClientProvider extends EventEmitter3<UPClientProviderEvents> {\n  readonly #options: UPClientProviderOptions\n  #buffered?: Array<[keyof UPClientProviderEvents, unknown[]]> = []\n  constructor(options: any) {\n    super()\n    this.#options = options as UPClientProviderOptions\n  }\n\n  emit<T extends EventEmitter.EventNames<UPClientProviderEvents>>(event: T, ...args: EventEmitter.EventArgs<UPClientProviderEvents, T>): boolean {\n    if (this.#buffered) {\n      this.#buffered.push([event, args])\n      return false\n    }\n    return super.emit(event, ...args)\n  }\n\n  resume(delay = 0) {\n    const buffered = this.#buffered\n    if (!buffered) {\n      return\n    }\n    this.#buffered = undefined\n    setTimeout(() => {\n      while (buffered.length > 0) {\n        const val = buffered.shift()\n        if (val) {\n          const [event, args] = val\n          super.emit(event, ...(args as any))\n        }\n      }\n    }, delay)\n  }\n\n  on<T extends EventEmitter.EventNames<UPClientProviderEvents>>(event: T, fn: EventEmitter.EventListener<UPClientProviderEvents, T>, context?: any) {\n    this.resume(100)\n    return super.on(event, fn, context)\n  }\n  addListener<T extends EventEmitter.EventNames<UPClientProviderEvents>>(event: T, fn: EventEmitter.EventListener<UPClientProviderEvents, T>, context?: any) {\n    this.resume(100)\n    return super.addListener(event, fn, context)\n  }\n\n  private _getOptions = () => {\n    return this.#options\n  }\n\n  get isUPClientProvider(): boolean {\n    return true\n  }\n\n  get isConnected(): boolean {\n    return this._getOptions().allowedAccounts().length > 0\n  }\n\n  get isMiniApp(): Promise<boolean> {\n    return this._getOptions()\n      ?.startupPromise.catch(() => false)\n      .then(() => true)\n  }\n\n  async request(method: { method: string; params?: JSONRPCParams }, clientParams?: any): Promise<any>\n  async request(method: string, params?: JSONRPCParams, clientParams?: any): Promise<any>\n  async request(_method: string | { method: string; params?: JSONRPCParams }, _params?: JSONRPCParams, _clientParams?: any): Promise<any> {\n    await this._getOptions()?.startupPromise\n    // Internally this will decode method.method and method.params if it was sent.\n    // i.e. this method is patched.\n    const method = typeof _method === 'string' ? _method : _method.method\n    const params = typeof _method === 'string' ? _params : _method.params\n    const clientParams = typeof _method === 'string' ? _clientParams : _params\n    if (method === 'up_contextAccounts') {\n      return this._getOptions().contextAccounts()\n    }\n    return this._getOptions()?.client?.request(method, params, clientParams) || null\n  }\n\n  get chainId() {\n    return this._getOptions()?.chainId() || 0\n  }\n\n  get accounts() {\n    return this._getOptions()?.allowedAccounts() || []\n  }\n\n  get contextAccounts() {\n    return this._getOptions()?.contextAccounts() || []\n  }\n}\n\n/**\n * @internal\n * Search for the parent provider and connect it. This routine is internally called\n * @param up - search input if specific window should be pinged.\n * @param remote - the provider doing the pinging.\n * @param options - the internal closure for that provider.\n * @returns The provider if it successfully connected or throws an error.\n */\nasync function testWindow(up: Window | undefined | null, remote: UPClientProvider, options: UPClientProviderOptions): Promise<UPClientProvider> {\n  const _up = up || (typeof window !== 'undefined' ? window : undefined)\n  if (!_up) {\n    throw new Error('No UP found')\n  }\n  return new Promise<UPClientProvider>((resolve, reject) => {\n    let timeout: number | NodeJS.Timeout = 0\n    const channel = new MessageChannel()\n\n    const testFn = (event: MessageEvent) => {\n      if (event.data?.type === 'upProvider:windowInitialize') {\n        const { chainId, allowedAccounts, contextAccounts, rpcUrls } = event.data\n\n        clientLog('client init', event.data, _up)\n        window.removeEventListener('message', testFn)\n        if (timeout) {\n          clearTimeout(timeout)\n          timeout = 0\n        }\n        options.clientChannel = channel.port1\n        options.window = _up\n        try {\n          _up.addEventListener('close', () => {\n            options.restart()\n            remote.emit('windowClosed')\n          })\n        } catch {\n          // Ignore\n        }\n        options.init = { chainId, allowedAccounts, contextAccounts, rpcUrls }\n        clientLog('client connected', event.data.type, event.data)\n        options.clientChannel.postMessage({\n          type: 'upProvider:windowInitialized',\n          chainId,\n          allowedAccounts,\n          contextAccounts,\n          rpcUrls,\n        })\n        resolve(remote)\n      }\n    }\n\n    channel.port1.addEventListener('message', testFn)\n    channel.port1.start()\n    window.addEventListener('message', testFn)\n    clientLog('client', 'send find wallet', _up)\n    _up.postMessage('upProvider:hasProvider', '*', [channel.port2])\n\n    timeout = setTimeout(() => {\n      timeout = 0\n      window.removeEventListener('message', testFn)\n      channel.port1.removeEventListener('message', testFn)\n\n      clientLog('client', 'No UP found', _up)\n      reject(new Error('No UP found'))\n    }, 1000)\n  })\n}\n\n/**\n * Find the up connector in the parent or popup window.\n * @param authURL - optionlly pass a URL for a popup to be launched in an iframe to connect\n * @param remote - the up provider to be connect\n * @param options - the internal closure for that provider.\n * @returns\n */\nasync function findUP(authURL: UPWindowConfig, remote: UPClientProvider, options: UPClientProviderOptions): Promise<UPClientProvider | undefined> {\n  if (typeof authURL === 'object' && !(authURL instanceof Window) && authURL?.url) {\n    const info = localStorage.getItem(`upProvider:info:${authURL}`)\n    if (info) {\n      const { chainId, allowedAccounts, contextAccounts, rpcUrls } = JSON.parse(info)\n      options.init = { chainId, allowedAccounts, contextAccounts, rpcUrls }\n    }\n    if (typeof window !== 'undefined' && typeof document !== 'undefined') {\n      if (authURL.mode === 'popup') {\n        const childWindow = window.open(authURL.url, 'UE Wallet', 'width=400,height=600')\n        if (childWindow) {\n          const up = await testWindow(childWindow, remote, options)\n          if (up) {\n            return up\n          }\n        }\n      }\n      if (authURL.mode === 'iframe') {\n        const popup = createWalletPopup()\n        if (popup) {\n          const current = await popup.openModal(authURL.url)\n          if (current) {\n            current.addEventListener('close', () => {\n              options.restart()\n              remote.emit('windowClosed')\n            })\n            const up = await testWindow(current, remote, options)\n            if (up) {\n              return up\n            }\n            throw new Error('No UP found')\n          }\n        }\n      }\n    }\n    return\n  }\n  const current = typeof window !== 'undefined' && window instanceof Window ? window.opener || window.parent : null\n  if (current) {\n    const up = await testWindow(current, remote, options)\n    if (up) {\n      return up\n    }\n  }\n  if (authURL == null) {\n    throw new Error('No UP found')\n  }\n  if (typeof authURL === 'object' && authURL instanceof Window) {\n    throw new Error('No UP found')\n  }\n  throw new Error('No UP found')\n}\n\n/**\n * Helper routines to initiate the search procedure for the parent provider.\n * @param authURL - optional URL for popup window\n * @param remote - the up provider to be connected\n * @param options - the internal closure for that provider.\n * @param search - if true then it will search, else it expects either a window or URL.\n * @returns The connected provider or throws an error.\n */\nasync function findDestination(authURL: UPWindowConfig, remote: UPClientProvider, options: UPClientProviderOptions, search = false): Promise<UPClientProvider> {\n  let up: UPClientProvider | undefined =\n    (typeof authURL === 'object' && authURL instanceof Window) || authURL == null\n      ? await testWindow(authURL, remote, options).catch(error => {\n          if (search) {\n            return undefined\n          }\n          throw error\n        })\n      : await findUP(authURL, remote, options)\n\n  if (search && !up) {\n    let retry = 3\n    while (retry > 0) {\n      let current: Window | undefined = window.opener && window.opener !== window ? window.opener : window.parent && window.parent !== window ? window.parent : undefined\n      clientLog('search', current)\n      while (current) {\n        up = await testWindow(current, remote, options).catch(() => undefined)\n        if (up) {\n          break\n        }\n        if (current === window.top) {\n          break\n        }\n        clientLog('current', current)\n        current = current.opener && current.opener !== current ? current.opener : current.parent && current.parent !== current ? current.parent : null\n        clientLog('next', current)\n      }\n      if (up) {\n        break\n      }\n\n      // Wait for a second for each try.\n      await new Promise(resolve => setTimeout(resolve, 1000))\n\n      retry--\n    }\n  }\n  if (!up) {\n    throw new Error('No UP found')\n  }\n  return up\n}\n\n/**\n * Create clientUPProvider. This can be used like a normal window.ethereum or window.lukso provider.\n * It will on initialization look for a connection to a global provider.\n *\n * @param authURL Optionally put a URL to a authentication provider to provide the global provider.\n * @param search If false then don't search but take the passed in value as is.\n * @returns the client UPProvider\n */\nfunction createClientUPProvider(authURL?: UPWindowConfig, search = true): UPClientProvider {\n  let chainId = 0\n  let allowedAccounts: `0x${string}`[] = []\n  let contextAccounts: `0x${string}`[] = []\n  let rpcUrls: string[] = []\n  let startupResolve: () => void\n\n  let startupPromise = new Promise<void>(resolve => {\n    startupResolve = resolve\n  }).then(() => {\n    remote.emit('initialized')\n  })\n\n  const options: UPClientProviderOptions = {\n    chainId: () => chainId,\n    restart: () => {},\n    allowedAccounts: () => allowedAccounts,\n    contextAccounts: () => contextAccounts,\n    startupPromise,\n  }\n\n  options.restart = function restart() {\n    options.startupPromise = startupPromise = new Promise<void>(resolve => {\n      startupResolve = resolve\n    }).then(() => {\n      remote.emit('initialized')\n    })\n  }\n\n  const remote = new _UPClientProvider(options)\n  let searchPromise: Promise<UPClientProvider> | null\n\n  // Register the provider as a wallet by announcing it.\n  const providerInfo = {\n    uuid: uuidv4(),\n    name: 'UE Universal Profile',\n    icon: `data:image/svg+xml,${encodeURIComponent(image)}`,\n    rdns: 'dev.lukso.auth',\n  }\n\n  // Announce event.\n  const announceEvent = new CustomEvent('eip6963:announceProvider', {\n    detail: Object.freeze({ info: providerInfo, provider: remote }),\n  })\n\n  // The Wallet dispatches an announce event which is heard by\n  // the DApp code that had run earlier\n  window.dispatchEvent(announceEvent)\n\n  // The Wallet listens to the request events which may be\n  // dispatched later and re-dispatches the `EIP6963AnnounceProviderEvent`\n  window.addEventListener('eip6963:requestProvider', () => {\n    window.dispatchEvent(announceEvent)\n  })\n\n  const doSearch = async (client: JSONRPCClient, force = false): Promise<UPClientProvider> => {\n    if (searchPromise) {\n      return searchPromise\n    }\n    const activeSearchPromise = findDestination(authURL, remote, options, search)\n      .then(up => {\n        up?.addListener('windowClosed', () => {\n          searchPromise = null\n        })\n        const init:\n          | {\n              chainId: number\n              allowedAccounts: `0x${string}`[]\n              contextAccounts: `0x${string}`[]\n              rpcUrls: string[]\n            }\n          | undefined = options.init\n        if (init) {\n          ;({ chainId, allowedAccounts, contextAccounts, rpcUrls } = init || {})\n        }\n        options.clientChannel?.addEventListener('message', event => {\n          const fn = startupResolve\n          if (fn) {\n            fn()\n          }\n          startupResolve = () => {}\n          try {\n            const response = event.data\n            clientLog('client', response)\n            switch (response.method) {\n              case 'chainChanged':\n                chainId = response.params[0]\n                up.emit('chainChanged', chainId)\n                return\n              case 'contextAccountsChanged':\n                contextAccounts = response.params\n                up.emit(\n                  'contextAccountsChanged',\n                  // Cleanup wrong null or undefined.\n                  cleanupAccounts(contextAccounts)\n                )\n                return\n              case 'accountsChanged':\n                allowedAccounts = response.params\n                up.emit(\n                  'accountsChanged',\n                  // Cleanup wrong null or undefined.\n                  cleanupAccounts(allowedAccounts)\n                )\n                return\n              case 'rpcUrlsChanged':\n                rpcUrls = response.params\n                up.emit('rpcUrls', rpcUrls)\n                return\n            }\n            const item = pendingRequests.get(response.id)\n            if (response.id && item) {\n              const { resolve, reject } = item\n              if (response.result) {\n                client.receive({ ...response, id: item.id }) // Handle the response\n                resolve() // Resolve the corresponding promise\n              } else if (response.error) {\n                const { error: _error, jsonrpc } = response\n                const { method, params, id } = item\n                const error = {\n                  ..._error,\n                  message: `${_error.message} ${JSON.stringify(method)}(${JSON.stringify(params)})`,\n                }\n                // This is a real error log (maybe goes to sentry)\n                console.error('error', { error, method, params, id, jsonrpc })\n                client.receive({ ...response, id: item.id })\n                reject(error) // Reject in case of error\n              }\n              pendingRequests.delete(response.id) // Clean up the request\n            }\n          } catch (error) {\n            // This is a real error log (maybe goes to sentry)\n            console.error('Error parsing JSON RPC response', error, event)\n          }\n        })\n        options.clientChannel?.start()\n        options.client = client\n        return up\n      })\n      .catch(error => {\n        options.client = client\n\n        startupResolve()\n        searchPromise = null\n        throw error\n      })\n      .then(up => {\n        if (!up) {\n          searchPromise = null\n        }\n        return up\n      })\n    searchPromise = activeSearchPromise\n    return activeSearchPromise\n  }\n\n  const allocateConnection = async () => {\n    const client = new JSONRPCClient(async (jsonRPCRequest: any) => {\n      await doSearch(client).then(up => {\n        options.client = client\n        return up\n      })\n\n      return new Promise((resolve, reject) => {\n        const { id, method, params } = jsonRPCRequest\n\n        pendingRequests.set(id, {\n          resolve,\n          reject,\n          sent: false,\n          id,\n          method,\n          params,\n        })\n\n        options.clientChannel?.postMessage(jsonRPCRequest)\n      })\n    })\n\n    const request_ = client.request.bind(client)\n\n    const wrapper = async (method: string, params?: unknown[]) => {\n      switch (method) {\n        case 'eth_call':\n          // Is this call is used to evaluate or simulate a transaction then we have to send it to the parent provider.\n          // Otherwise we can send it directly to a configured RPC endpoint.\n          if (rpcUrls.length > 0 && Object.keys((params?.[0] ?? {}) as Record<string, unknown>).every(key => !/^gasPrice|maxFeePerGas|maxPriorityFeePerGas|value$/.test(key))) {\n            clientLog('client direct rpc', rpcUrls, method, params)\n\n            const urls = [...rpcUrls]\n            const errors = []\n            while (urls.length > 0) {\n              const url = urls.shift()\n              try {\n                if (!url) {\n                  throw new Error('No RPC URL found')\n                }\n\n                const result = fetch(url, {\n                  method: 'POST',\n                  headers: {\n                    'Content-Type': 'application/json',\n                  },\n                  body: JSON.stringify({\n                    jsonrpc: '2.0',\n                    id: uuidv4(),\n                    method,\n                    params,\n                  }),\n                }).then(response => {\n                  if (response.ok) {\n                    return response.json()\n                  }\n                  throw new Error('Network response was not ok')\n                })\n\n                return result\n              } catch (error) {\n                // This is a real error log (maybe goes to sentry)\n                console.error('error', error)\n                errors.push(error)\n              }\n            }\n            const err: any = new Error(`All RPC URLs failed: ${errors.map(e => (e as { message: string }).message).join(', ')}`)\n            err.errors = errors\n            throw err\n          }\n      }\n      return request_(method, params)\n    }\n\n    client.request = async (method: string | { method: string; params: unknown[] }, params?: unknown[]) => {\n      await doSearch(client)\n\n      await startupPromise\n\n      // make it compatible with old and new type RPC.\n      if (typeof method === 'string') {\n        return await wrapper(method, params)\n      }\n      const { method: _method, params: _params } = method\n      return await wrapper(_method, _params)\n    }\n\n    await doSearch(client)\n  }\n\n  if (!authURL || !(authURL as { url: string; mode: 'popup' | 'iframe' })?.url) {\n    allocateConnection()\n  }\n\n  return remote\n}\n\nexport { type UPClientProvider, type UPClientProviderEvents, createClientUPProvider }\n","import { LitElement, html, css, type PropertyDeclarations } from 'lit'\n\n/**\n * Small lit component to work on popup.\n * This is not being called quite yet but will be the way to support\n * the popup in the future.\n */\nexport class ModalPopup extends LitElement {\n  static styles = css`\n    .modal {\n      display: none;\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      background-color: rgba(0, 0, 0, 0.5);\n      justify-content: center;\n      align-items: center;\n    }\n    .modal.show {\n      display: flex;\n    }\n    .modal-content {\n      background-color: #fff;\n      border-radius: 8px;\n      overflow: hidden;\n      position: relative;\n      /* Default size for larger screens */\n      width: 480px;\n      height: 640px;\n      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);\n    }\n    /* Fullscreen iframe for mobile devices */\n    @media (max-width: 768px) {\n      .modal-content {\n        width: 100%;\n        height: 100%;\n        border-radius: 0; /* Remove rounded corners on mobile */\n      }\n    }\n    .close-button {\n      position: absolute;\n      top: 10px;\n      right: 15px;\n      font-size: 24px;\n      cursor: pointer;\n      z-index: 10;\n    }\n    iframe {\n      width: 100%;\n      height: 100%;\n      border: none;\n    }\n  `\n\n  static properties: PropertyDeclarations = {\n    isOpen: { type: Boolean },\n    iframeSrc: { type: String },\n  }\n\n  isOpen = false\n  iframeSrc = ''\n\n  private iframeElement: HTMLIFrameElement | null | undefined\n\n  render() {\n    return html`\n      <div class=\"modal ${this.isOpen ? 'show' : ''}\">\n        <div class=\"modal-content\">\n          <span class=\"close-button\" @click=\"${this.closeModal}\">&times;</span>\n          <iframe src=\"about:blank\"></iframe>\n        </div>\n      </div>\n    `\n  }\n\n  handleIframeLoad = () => {\n    const { contentWindow } = (this.iframeElement || {}) as HTMLIFrameElement\n    this.resolve?.(contentWindow)\n  }\n\n  handleIframeError = (e: ErrorEvent) => {\n    this.reject?.(e.error)\n    this.closeModal()\n  }\n\n  private resolve?: (window: Window | null) => void\n  private reject?: (error: Error) => void\n\n  async openModal(url: string): Promise<Window | null> {\n    const defer = new Promise<Window | null>((resolve, reject) => {\n      this.resolve = resolve\n      this.reject = reject\n    })\n    this.iframeSrc = url\n    this.isOpen = true\n\n    if (this.iframeElement) {\n      this.iframeElement.src = url\n    }\n    return defer\n  }\n\n  firstUpdated() {\n    this.iframeElement = this.renderRoot.querySelector('iframe') as HTMLIFrameElement\n    if (this.iframeElement) {\n      this.iframeElement.addEventListener('load', this.handleIframeLoad)\n      this.iframeElement.addEventListener('error', this.handleIframeError)\n\n      if (this.iframeSrc) {\n        this.iframeElement.src = this.iframeSrc\n      }\n    }\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback()\n    // Clean up event listeners\n    if (this.iframeElement) {\n      this.iframeElement.removeEventListener('load', this.handleIframeLoad)\n      this.iframeElement.removeEventListener('error', this.handleIframeError)\n      this.iframeElement = null\n    }\n  }\n\n  closeModal() {\n    this.isOpen = false\n    this.iframeSrc = ''\n  }\n}\n\nexport function createWalletPopup(): ModalPopup | null {\n  if (typeof window === 'undefined' || typeof document === 'undefined' || typeof customElements === 'undefined') {\n    return null\n  }\n  // Manually register the custom element\n  if (!customElements.get('up-wallet-popup')) {\n    customElements.define('up-wallet-popup', ModalPopup)\n  }\n  const existingPopup: ModalPopup | null = (document.querySelector('up-wallet-popup') || null) as ModalPopup | null\n  if (existingPopup) {\n    return existingPopup\n  }\n  const popup = document.createElement('up-wallet-popup') as ModalPopup\n  document.body.appendChild(popup)\n  return popup\n}\n","export * from './client'\nexport * from './server'\nexport * from './popup'\n\n/**\n * Small helper function to compare two arrays of addresses.\n * This allow null, undefined, or empty strings to be considered the same.\n * @param _addresses1 - array 1\n * @param _addresses2 - array 2\n * @returns Returns true if there were changes between the two arrays.\n */\nexport const arrayChanged = (_addresses1?: Array<`0x${string}` | string | null | undefined>, _addresses2?: Array<`0x${string}` | string | null | undefined>) => {\n  const addresses1 = _addresses1 ?? []\n  const addresses2 = _addresses2 ?? []\n  for (let i = 0; i < addresses1.length || i < addresses2.length; i++) {\n    const is1Null = addresses1[i] === null || addresses1[i] === undefined\n    const is2Null = addresses2[i] === null || addresses2[i] === undefined\n    if (is1Null && is2Null) {\n      continue\n    }\n    if (addresses1[i] !== addresses2[i]) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Cleanup accounts array so there are no sparse values (i.e. empty values in the middle, this is not compatible\n *  with many of the web3 libraries (web3.js and viem)).\n * @param values - original array\n * @returns Returns copy of array which makes 0x00..., null, undefined and empty string mark the end of the array\n *         This is useful for cleaning up the array of accounts.\n */\nexport const cleanupAccounts = (values: Array<`0x${string}` | undefined>): `0x${string}`[] => {\n  const output = []\n  for (const value of values) {\n    if (!value || /^0x0+$/.test(value)) {\n      break\n    }\n    output.push(value)\n  }\n  return output as Array<`0x${string}`>\n}\n"],"mappings":"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","names":["debug","EventEmitter3","uuidv4","debug","EventEmitter3","window","uuidv4","_chainId","_accounts","accountsChanged","event"]}