import { EventEmitter } from 'eventemitter3';
import { JSONRPCError, JSONRPCParams } from 'json-rpc-2.0';

interface UPClientChannelEvents {
    connected: () => void;
    disconnected: () => void;
    contextAccountsChanged: (accounts: `0x${string}`[]) => void;
    accountsChanged: (accounts: `0x${string}`[]) => void;
    requestAccounts: (accounts: `0x${string}`[]) => void;
    chainChanged: (chainId: number) => void;
    injected: (accounts: `0x${string}`[]) => void;
    sentTransaction: (tx: {
        from: `0x${string}`;
        to: `0x${string}`;
        value?: bigint;
        error?: JSONRPCError;
        result?: any;
    }) => void;
}
/**
 * API for client channel, each time an iframe's UPClientProvider is allocated and connected
 * the UPProviderConnector will create and emit a new UPClientChannel.
 * The UPClientChannel will have the API to control that channel.
 * The configuration will default to values from the UPProviderConnector but enable will be false.
 */
interface UPClientChannel {
    readonly window: Window;
    readonly element: HTMLIFrameElement | null;
    readonly id: string;
    /**
     * Return an array listing the events for which the emitter has registered
     * listeners.
     */
    eventNames(): Array<EventEmitter.EventNames<UPClientChannelEvents>>;
    /**
     * Return the listeners registered for a given event.
     */
    listeners<T extends EventEmitter.EventNames<UPClientChannelEvents>>(event: T): Array<EventEmitter.EventListener<UPClientChannelEvents, T>>;
    /**
     * Return the number of listeners listening to a given event.
     */
    listenerCount(event: EventEmitter.EventNames<UPClientChannelEvents>): number;
    /**
     * Calls each of the listeners registered for a given event.
     */
    emit<T extends EventEmitter.EventNames<UPClientChannelEvents>>(event: T, ...args: EventEmitter.EventArgs<UPClientChannelEvents, T>): boolean;
    /**
     * Add a listener for a given event.
     */
    on<T extends EventEmitter.EventNames<UPClientChannelEvents>>(event: T, fn: EventEmitter.EventListener<UPClientChannelEvents, T>, context?: any): this;
    addListener<T extends EventEmitter.EventNames<UPClientChannelEvents>>(event: T, fn: EventEmitter.EventListener<UPClientChannelEvents, T>, context?: any): this;
    /**
     * Add a one-time listener for a given event.
     */
    once<T extends EventEmitter.EventNames<UPClientChannelEvents>>(event: T, fn: EventEmitter.EventListener<UPClientChannelEvents, T>, context?: any): this;
    /**
     * Remove the listeners of a given event.
     */
    removeListener<T extends EventEmitter.EventNames<UPClientChannelEvents>>(event: T, fn?: EventEmitter.EventListener<UPClientChannelEvents, T>, context?: any, once?: boolean): this;
    off<T extends EventEmitter.EventNames<UPClientChannelEvents>>(event: T, fn?: EventEmitter.EventListener<UPClientChannelEvents, T>, context?: any, once?: boolean): this;
    /**
     * Remove all listeners, or those of the specified event.
     */
    removeAllListeners(event?: EventEmitter.EventNames<UPClientChannelEvents>): this;
    /**
     * Resume after a delay
     * @param delay - delay in milliseconds
     */
    resume(delay: number): void;
    /**
     * Send message to dapp.
     * @param method - method name/event
     * @param params - parameters
     */
    send(method: string, params: unknown[]): Promise<void>;
    /**
     * This represents the normal "eth_accounts" method list.
     * @param accounts - list of addresses
     */
    setAllowedAccounts(accounts: `0x${string}`[]): Promise<void>;
    /**
     * This represents the normal "eth_accounts" method list. (setter mirrors setAllowedAccounts)
     */
    set allowedAccounts(accounts: `0x${string}`[]);
    /**
     * This represents the normal "eth_accounts" method list.
     * @returns list of accounts
     */
    get allowedAccounts(): `0x${string}`[];
    /**
     * These are extra accounts sent to each provider. In the ue.io grid, this is used to
     * represent the account that is the grid owner.
     * @param accounts - list of addresses
     */
    setContextAccounts(contextAccounts: `0x${string}`[]): Promise<void>;
    /**
     * These are extra accounts sent to each provider. In the ue.io grid, this is used to
     * represent the account that is the grid owner. (setter mirrors setContextAccounts)
     * @param accounts - list of addresses
     */
    set contextAccounts(contextAccounts: `0x${string}`[]);
    /**
     * These are extra accounts sent to each provider. In the ue.io grid, this is used to
     * represent the account that is the grid owner.
     * @returns list of addresses
     */
    get contextAccounts(): `0x${string}`[];
    /**
     * ChainId
     * @param chainId - chain id
     */
    setChainId(chainId: number): Promise<void>;
    /**
     * ChainId
     * @param chainId - chain id
     */
    set chainId(chainId: number);
    /**
     * ChainId
     * @returns chain id
     */
    get chainId(): number;
    /**
     * Enable or disable the channel.
     * @param enable - enable or disable the channel
     */
    setEnable(enable: boolean): Promise<void>;
    /**
     * Enable or disable the channel.
     * @returns is channel enabled
     */
    get enable(): boolean;
    /**
     * Enable or disable the channel.
     * @param enable - enable or disable the channel
     */
    set enable(value: boolean);
    /**
     * RPC urls
     * @param rpcUrls - list of rpc urls (used by client provider to short circuit requests)
     */
    setRpcUrls(rpcUrls: string[]): Promise<void>;
    /**
     * RPC urls
     * @param rpcUrls - list of rpc urls (used by client provider to short circuit requests)
     */
    set rpcUrls(rpcUrls: string[]);
    /**
     * RPC urls
     * @returns list of rpc urls (used by client provider to short circuit requests)
     */
    get rpcUrls(): string[];
    /**
     * Helper to setup the channel with all the necessary information.
     * @param enable - enable
     * @param accounts - accounts (allowed accounts)
     * @param contextAccounts - context accounts
     * @param chainId - chainId
     */
    setupChannel(enable: boolean, accounts: `0x${string}`[], contextAccounts: `0x${string}`[], chainId: number): Promise<void>;
    /**
     * Close the channel
     */
    close(): void;
}
interface UPProviderEndpointEvents {
    accountsChanged: (accounts: `0x${string}`[]) => void;
    chainChanged: (chainId: number) => void;
    connect: ({ chainId }: {
        chainId: number;
    }) => void;
    disconnect: (error: Error) => void;
}
interface UPProviderEndpoint {
    on<T extends EventEmitter.EventNames<UPProviderEndpointEvents>>(event: T, fn: EventEmitter.EventListener<UPProviderEndpointEvents, T>, context?: any): this;
    off<T extends EventEmitter.EventNames<UPProviderEndpointEvents>>(event: T, fn: EventEmitter.EventListener<UPProviderEndpointEvents, T>, context?: any): this;
    request(message: {
        method: string;
        params: JSONRPCParams;
    }, clientParams?: any): Promise<any>;
    request(method: string | {
        method: string;
        params: JSONRPCParams;
    }, params?: JSONRPCParams, clientParams?: any): Promise<any>;
}
interface UPProviderConnectorEvents {
    channelCreated: (id: HTMLIFrameElement | Window | string, channel: UPClientChannel) => void;
}
/**
 * API for provider connector
 */
interface UPProviderConnector {
    /**
     * Return an array listing the events for which the emitter has registered
     * listeners.
     */
    eventNames(): Array<EventEmitter.EventNames<UPProviderConnectorEvents>>;
    /**
     * Return the listeners registered for a given event.
     */
    listeners<T extends EventEmitter.EventNames<UPProviderConnectorEvents>>(event: T): Array<EventEmitter.EventListener<UPProviderConnectorEvents, T>>;
    /**
     * Return the number of listeners listening to a given event.
     */
    listenerCount(event: EventEmitter.EventNames<UPProviderConnectorEvents>): number;
    /**
     * Calls each of the listeners registered for a given event.
     */
    emit<T extends EventEmitter.EventNames<UPProviderConnectorEvents>>(event: T, ...args: EventEmitter.EventArgs<UPProviderConnectorEvents, T>): boolean;
    /**
     * Add a listener for a given event.
     */
    on<T extends EventEmitter.EventNames<UPProviderConnectorEvents>>(event: T, fn: EventEmitter.EventListener<UPProviderConnectorEvents, T>, context?: any): this;
    addListener<T extends EventEmitter.EventNames<UPProviderConnectorEvents>>(event: T, fn: EventEmitter.EventListener<UPProviderConnectorEvents, T>, context?: any): this;
    /**
     * Add a one-time listener for a given event.
     */
    once<T extends EventEmitter.EventNames<UPProviderConnectorEvents>>(event: T, fn: EventEmitter.EventListener<UPProviderConnectorEvents, T>, context?: any): this;
    /**
     * Remove the listeners of a given event.
     */
    removeListener<T extends EventEmitter.EventNames<UPProviderConnectorEvents>>(event: T, fn?: EventEmitter.EventListener<UPProviderConnectorEvents, T>, context?: any, once?: boolean): this;
    off<T extends EventEmitter.EventNames<UPProviderConnectorEvents>>(event: T, fn?: EventEmitter.EventListener<UPProviderConnectorEvents, T>, context?: any, once?: boolean): this;
    /**
     * Remove all listeners, or those of the specified event.
     */
    removeAllListeners(event?: EventEmitter.EventNames<UPProviderConnectorEvents>): this;
    close(): void;
    get provider(): UPProviderEndpoint;
    /**
     * Get a map of all clients by their ID.
     */
    get channels(): Map<string, UPClientChannel>;
    /**
     * Find the client for the element, window or proxy object of the client.
     * @param id
     * @returns actual UPClientChannel
     */
    getChannel(id: string | Window | HTMLIFrameElement | UPClientChannel | null): UPClientChannel | null;
    /**
     * Inject additional addresses into the client's accountsChanged event.
     * Account[0] will be linked to the signed when making transactions.
     * Starting at Account[1] is where additional addresses are injected.
     * This routine injects on all connections. You can also inject using
     * the channel's allowedAccounts method.
     * @param page list of addresses
     */
    setContextAccounts(accounts: `0x${string}`[]): Promise<void>;
    set contextAccounts(accounts: `0x${string}`[]);
    get contextAccounts(): `0x${string}`[];
    setAllowedAccounts(accounts: `0x${string}`[]): Promise<void>;
    set allowedAccounts(accounts: `0x${string}`[]);
    get allowedAccounts(): `0x${string}`[];
    setChainId(chainId: number): Promise<void>;
    set chainId(chainId: number);
    get chainId(): number;
    /**
     * Connect this provider externally. This will be called during initial construction
     * but can be called at a later time if desired to re-initialize or tear down
     * the connection.
     * @param provider
     * @param rpcUrls
     */
    setupProvider(provider: UPProviderEndpoint, rpcUrls: string | string[]): Promise<void>;
}
/**
 * Global method to find channel in case `up-channel-connected` event was missed.
 *
 * @param id how to find the UPClientChannel instance (this can be the id, frame (not the frame's element id) or window)
 * @returns UPClientChannel
 */
declare function getUPProviderChannel(id: string | Window | HTMLIFrameElement | UPClientChannel | null): UPClientChannel | null;
/**
 * Install a global UPProvider inside of the particular window which will listen for client
 * connections and establish them. It will fire `up-channel-connected` on the particular iframe if it's reachable.
 * It will fire a local `channelCreated` event as well.
 *
 * @param provider the initial provider to proxy
 * @param rpcUrls rpc urls to give to the clients to locally connect for non eth_sendTransaction and so on.
 * @returns The global provider and event sing for `channelCreated` events.
 */
declare function createUPProviderConnector(provider?: any, rpcUrls?: string | string[]): UPProviderConnector;

export { type UPClientChannel, type UPClientChannelEvents, type UPProviderConnector, type UPProviderConnectorEvents, type UPProviderEndpoint, type UPProviderEndpointEvents, createUPProviderConnector, getUPProviderChannel };
